---
title: "Lecture 10: More on Dynamic Models"
format: revealjs
theme: solarized
resources: ["img/"]
css: ["slides.css"]
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(purrr)
library(deSolve)
library(here)
```

## What are dynamic models {.scrollable}

Dynamic model use differential equations to describe how a system is changing

-   state-variables - the variables that the model is tracking/estimating over time (e.g population size)
-   parameters/inputs - the values that determine how the system changes (e.g growth rate)

how the state variables evolve described by differential equations

## Some examples {.scrollable}

For all state variables you would have a derivative

-   wolf population growth
    -   state variables (wolf, deer, vegetation)
    -   parameters (growth rates, carrying capacity, climate)
-   snowpack
    -   state variable - (amount of snow)
    -   parameters/inputs (sunlight, temperature, precipitation, wind)
-   dams emissions of CO2
    -   state variable (sediment, bioaccumulation, dissolved CO2) (maybe water temperature, water level)
    -   parameters inputs (sediment inputs, temperature, precipitation, dam operations)
-   wildfire smoke impacts on drinking water
    -   state variable (contaminant concentration in air, water)
    -   parameters/inputs (wildfire size, wind, precipitation, water flow, biomass lost in fire) (really complicated as a dynamic model, versus simple statistical model of smoke impacts on water quality)
-   groundwater
    -   state variable (groundwater level, contaminant concentration)
    -   parameters/inputs (precipitation, pumping, recharge, geology)

## Integration of state variables to evolve the system through time (or space) {.scrollable}

Two options

[ 1) explicit solution to differential equation is known; ]{style="color: blue;"}

-   this means you can integrate by 'math' - analytical solution
-   we did this - $P = PO * exp(rt)$ coded in *exppop.R*
-   you can get the answer exactly and quickly this way

[ 2) not integrable ]{style="color: blue;"}

-   must be solved by iteration;
-   add the derivative value to current state (time t), to create state at time t + 1
-   re-calculate rate of change (e.g value of differential equation for state at time t+1)
-   keep doing this

Key questions is how much of a "jump" in t do we do

If we use whole number jumps = e.g t, t+1, t+2 - we are doing a "discrete" approximation to the continuous change (difference equations)

## Solving by thinking of problem as a difference equations {.scrollable}

So we could implement them as difference equations and iterate

```{r iterate1}
source(here("R/discrete_logistic_pop.R"))
# look at function
# notice how a for loop is used to iterate

discrete_logistic_pop

# how many rabbits after 50 years given a growth of 0.05
# starting with 1 rabbit - but a carrying capcity of200
discrete_logistic_pop(P0 = 1, r = 0.05, T = 50)

# save results
discrete_result <- discrete_logistic_pop(P0 = 1, r = 0.05, T = 50)

# lets also keep the parameters for use later
P0 <- 1
r <- 0.05
T <- 50
```

## Compare discrete and analytic results {.scrollable}

Save the results from both to compare

```{r closed}

# reload our analytical model
source(here("R/exppop.R"))

# run exppopK for P0, r, K, T (same conditions as discrete)
analytic_result <- exppop(P0 = P0, r = r, T = T)

analytic_result
discrete_result

# why are they different
# look at trajectories for each point in time from 1 to 100

# create a dataframe to store results with time as first column
growth_result <- data.frame(time = seq(from = 1, to = 100))

# add a column using analytical growth model
growth_result$Panalytic <- growth_result$time %>% map_dbl(~ exppop(P0 = 1, r = 0.05, T = .x))

# add a column using discrete growth model
growth_result$Pdiscrete <- growth_result$time %>% map_dbl(~ discrete_logistic_pop(P0 = 1, r = 0.05, T = .x))
```

## Graph

```{r, graph2, eval=TRUE, echo=TRUE}

# gather both model results using a key called "Ptype", value "P"
tmp <- growth_result %>% gather(key = "Ptype", value = "P", -time)

# plot with model type as color
ggplot(tmp, aes(time, P, col = Ptype)) +
  geom_point()

# try running them for longer time periods to see what happens
# change the value of r, K , P0 - see how it effects the results

```

## Summary of what we've done

-   *exppop* - analytical solutions to population differential equation

-   *discrete_logistic_pop* - integrating by stepping through time

-   *dexppop* - the derivative (would need to be integrated to get populations over time),

## Solving using numeric integration {.scrollable}

Using a solver....when you can't do the integration by hand :)

Solvers integrate by iteration but doing so in a way that more closely *approximates* analytic integration

Use mathematical tricks to deal with the fact that the rate of change keeps changing :)

There are different types of *solvers*, some work better than others depending on the form of the derivative

## Numerical integration with ODE {.scrollable}

Implement the differential equation as a function that

-   returns: the derivative (as a list)

-   inputs: time, the variable(s) and a parameter list

(it needs time even though you donâ€™t use it)

My convention: name derivative functions starting with *d* to remind myself that they are computing a derivative

## ODE

Only works for Ordinary Differential Equations - single independent variable (in our case time)

Partial differential equations - more than 1 independent variable (e.g x and y if changing in space)

R has a solver called *ODE* for solving ordinary differential equations from package **desolve**

## *ODE* requires {.scrollable}

-   initial conditions
-   values of independent where we want values of dependent variable (e.g times where we want population)
-   the derivative as a function
-   a list that contains all parameter values (or if you have only one parameter then you can use a single value)

## ODE example {.scrollable}

```{r usingode}
source(here("R/dexppop.R"))

dexppop
library(deSolve)

# create initial conditions 20 rabbits
initialrabbits <- 20
# create a vector of years that you want results for - we can skip years (by 2)
years <- seq(from = 1, to = 100, by = 2)

# run the ode solver
Ptime <- ode(y = initialrabbits, times = years, func = dexppop, parms = c(0.01))
head(Ptime)
colnames(Ptime) <- c("year", "P")

# notice (by using attributes) that there are additional pieces of information including the method used for integration
attributes(Ptime)

# this also means you need to extract just the data frame for plotting
# make results a data frame
ggplot(as.data.frame(Ptime), aes(year, P)) +
  geom_point() +
  labs(y = "Population", x= "years")

# you can also run ode with function inputs in order but better to use names
Ptime <- ode(initialrabbits, years, dexppop, 0.01)
colnames(Ptime) <- c("year", "P")
ggplot(as.data.frame(Ptime), aes(year, P)) +
  geom_point() +
  labs(y = "Population", x="years")



```

## Comparing approaches {.scrollable}

-   analytical solution - based on integration (exppop.R) BEST
-   numerical integration by hand
-   using an ODE solver to do the numerical integration

```{r, all, echo=TRUE }
# create a dataframe to store results with time as first column
r = 0.05
growth_result <- data.frame(time = seq(from = 1, to = 100))

# add a column using analytical growth model
growth_result$Panalytic <- growth_result$time %>% map_dbl(~ exppop(P0 = 1, r = r, T = .x))

# add a column using discrete growth model
growth_result$Pdiscrete <- growth_result$time %>% map_dbl(~ discrete_logistic_pop(P0 = 1, r = r, T = .x))

tmp <- ode(y=1, times=growth_result$time, dexppop, parms=c(r))
growth_result$ode = tmp[,2]

# gather both model results using a key called "Ptype", value "P"
tmp <- growth_result %>% gather(key = "Ptype", value = "P", -time)

# plot with model type as color
p=ggplot(tmp, aes(time, P, col = Ptype)) +
  geom_point()
p

```

# Try it

-   try running them for longer time periods to see what happens
-   change the value of r, P0 - see how it effects the results

In discussion section we will go through an example of using an ODE solver to solve a population model with a carrying capacity (logistic growth) and compare to the analytical solution and the difference equation solution

## Differential Equation, Difference (Iteration by hand) comparison {.scrollable}

Remember we have 3 ways now to calculate population

-   analytical - based on integration (exppop.R) BEST

-   using an ode solver for numerical approximation (exppop_play.R)

-   numerical integration using in discrete steps (discrete_logistic_pop.R)

## Lets look at something a bit more complicated {.scrollable}

-   diffusion (how a contaminent moves through space and time)
-   start with 1 dimension in space

## Diffusion Conceptual model {.scrollable}

![](img/diffusion/diffusion.001.jpeg)

## Modeling Diffusion {.scrollable}

Diffusion in 4 dimensions (x,y,z,t) can be modelled using partial differential equations - time and space! it gets much more tricky ...beyond this course

Complicated to solve - but there are tool in R for specific types of partial differential equations [Reactive Transport Example](https://cran.r-project.org/web/packages/ReacTran/index.html)

More info on differential equations in R [online book differential equation in R](http://www-labs.iro.umontreal.ca/~mignotte/IFT2425/Documents/Solving_Differential_Equations_In_R_Soetaert_K.pdf)

More info on differential equations in Python - \[scipy\](https://docs.scipy.org/doc/scipy/reference/integrate.html#module-scipy.in has solvers for ordinary and partial differential equations - \[Solving Ordinary DIfferential Equations in Python\] (https://link.springer.com/book/10.1007/978-3-031-46768-4)

## Diffusion in 1 dimension {.scrollable}

![](img/diffusion/diffusion.002.jpeg)

## Diffusion in one dimension through time {.scrollable}

![](img/diffusion/diffusion.003.jpeg)

## Diffusion data structure {.scrollable}

![](img/diffusion/diffusion.004.jpeg)

## R implementation {.scrollable}

Lets do simple numerical integration with discrete steps

Look through *diffusion.R*

```{r}
source(here("R/diffusion.R"))

# run our diffusion model (iterative difference equation) with initial concentration of 10, for 8 timestep (size 1m), and 10 space steps (size 1s)
# using diffusion parameters 0.5 s/m2, 10 m2
result <- diff1(initialC = 10, nx = 10, dx = 1, nt = 8, dt = 1, D = 0.5, area = 10)

# a list is returned with our 3 data frames for concentration (conc), qin and qout
result

# used filled contour to plot results
head(result$conc)
filled.contour(result$conc, xlab = "Time", ylab = "Distance")

# or if you prefer this orientation (Distance on x axis)
filled.contour(t(result$conc), ylab = "Time", xlab = "Distance")

# you can also plot how much material is moving in to each cell at each time step
filled.contour(result$qin, xlab = "Time", ylab = "Distance")

```

## Change parameters (diffusivity D, and space and time steps (dx, dt)) {.scrollable}

Play on your own or with a partner

Try running the diffusion model with different time steps, space steps and parameters

## Some examples with different parameters and space/time steps {.scrollable}

```{r}
# changes diffusivity and other parameters particularly
# diffusivity, dx and dt
res <- diff1(initialC = 10, nx = 10, dx = 1, nt = 10, dt = 30, D = 0.006, area = 1)

filled.contour(res$conc, xlab = "Time", ylab = "Distance")


# we can also see how much material moved from place to place each time step
filled.contour(res$qin, xlab = "Time", ylab = "Distance")


# play with time step, space step and parameters
```

## More examples

```{r}
# what if we increase diffusivity
resfast <- diff1(initialC = 10, nx = 10, dx = 0.5, nt = 10, dt = 10, D = 0.08, area = 1)
filled.contour(resfast$conc, xlab = "Time", ylab = "Distance")


# Discretization Issue Example
resunstable <- diff1(initialC = 10, nx = 10, dx = 1, nt = 10, dt = 10, D = 0.8, area = 1)
filled.contour(resunstable$conc, xlab = "Time (fraction of hour)", ylab = "Distance Along Path (m)", main = "Pollutant Diffusion")

# this illustrates the problem with difference equations (and the challenges that methods for numerical integration try to overcome)
# if things are changing quickly we need to use much smaller time, space steps to avoid overshoot and instability

# so lets cut our step size by 10 (dt) (but then add 10 more steps (nx) to cover the same distance)
resunstable <- diff1(initialC = 10, nx = 100, dx = 1, nt = 10, dt = 1, D = 0.8, area = 1)
filled.contour(resunstable$conc, xlab = "time", ylab = "Distance Along Path")
```

## Dynamics Models {.scrollable}

-   Diffusion example illustrates the challenge of numerical integration

-   We see evidence of "overshoot"

-   Correct by reducing the time step (but then we have to increase the number of time steps to cover the same period)

## Diffusion Example {.scrollable}

```{r}
source(here("R/diffusion.R"))


# Change parameters (diffusivity D, and space and time steps (dx, dt))

res <- diff1(initialC = 100, nx = 10, dx = 1, nt = 10, dt = 30, D = 0.001, area = 1)
filled.contour(res$conc, xlab = "Time", ylab = "Distance", main = "Concentration through time and space")


# we can also see how much material is moving in to each cell at each time step
filled.contour(res$qin, xlab = "Time", ylab = "Distance", main = "Qin - material coming in ")

# we can also see net amount of material moved from place to place each time step
filled.contour(res$qin - res$qout, xlab = "Time", ylab = "Distance", main = "Qin-Qout NET ")

# what if we increase diffusivity
resfast <- diff1(initialC = 100, nx = 10, dx = 0.5, nt = 10, dt = 10, D = 0.08, area = 1)
filled.contour(resfast$conc, xlab = "Time", ylab = "Distance", main = "Concentration through time and space")
filled.contour(resfast$qin, xlab = "Time", ylab = "Distance", main = "Qin")


# this illustrates the problem with difference equations (and the challenges that methods for numerical integration try to overcome)
# if things are changing quickly we need to use much smaller time, space steps to avoid overshoot and instability

# so lets cut our step size by 10 (dt) (but then  multiply number of steps (nx) to cover the same distance)
resfast_fixtime <- diff1(initialC = 100, nx = 10, dx = 0.5, nt = 100, dt = 1, D = 0.08, area = 1)
filled.contour(resfast_fixtime$conc, xlab = "time", ylab = "Distance Along Path", main = "Concentration through time and space")

filled.contour(resfast_fixtime$qin, xlab = "Time", ylab = "Distance", main = "Qin")
filled.contour(resfast_fixtime$qin - resfast_fixtime$qout, xlab = "Time", ylab = "Distance", main = "Net Transport")
```
