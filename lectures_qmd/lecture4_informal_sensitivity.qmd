---
title: "Informal Sensitivity Analysis"
format:
  revealjs:
    theme: solarized
    resources: ["img/"]
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)

library(purrr)

library(ggpubr)

library(here)
```

# Questions?

# Solar PV Model Review

```{r solar, echo=TRUE}

source(here("R/solarpv.R"))


# read in R formatted data
load(here("Data/sierraczosolar.rda"))

# lets room the first and years since we know from last class that they are incomplete

sierraczosolar <- sierraczosolar %>% subset(year > 1944 & year < 1954)
# run the model
solarpv(area = 0.1, solar = sierraczosolar, clr = "green", eunit = "W")
```

```{r}
# remove the first year from the dataset
sierraczosolar <- sierraczosolar %>%
  filter(year > 1944)

# now run the model again
site1 <- solarpv(area = 0.1, 
          solar = sierraczosolar, clr = "green", eunit = "W", g = TRUE)

```

Try changing an input and see what you get!

# Playing with models

We often build models to try different options

**Model inputs**: solar radiation (daily direct and diffuse)

**Model outputs**: power generated each year and average power over time

**Parameters**: panel efficiency, system performance, units, type of array (uses diffuse or not), plot Y/N

```{r, echo=TRUE}
# consider a different PV array that only uses
# diffuse and has non standard efficiency (0.6)
site2 <- solarpv(area = 0.1, 
        solar = sierraczosolar, clr = "green", 
        eunit = "W", g = FALSE, eff = 0.6, etype = "direct")
site2$mean

# Compare with previous site
site1$mean
site2$mean
```

# Informal Sensitivity Analysis {.scrollable}

What happens when we vary parameters?

**Informal** - just try varying parameters

-   decide which parameter(s) and what range to vary the parameter over - what is the uncertainty? (+- 15% )?

-   figure out how to efficiently run your model over parameter variation and save results as you go

-   analyze the sensitivity (simply plotting for now)

## Helpful tools {.scrollable}

-   Sampling

    -   *runif*,
    -   *rnorm* (sampling from uniform and normal distributions)
    -   *seq* (for creating a sequence of numbers)

-   Repeating

    -   in R - *purrr* package, also *apply* family of function
    -   classic *for* loops

If you need it a good source to review working with *purrr* to extract items from list and repeat operations

[Useful Purrr Resource](https://www.rebeccabarter.com/blog/2019-08-19_purrr/)

# Example

-   we will start by using **map**
-   which "maps\* a function (runs it ) for a list of values,
-   we can also use these function to extract values from a list

# R code for informal sensitivity

We are not sure what the efficiency of the PV array is

How important is this parameter to the results?

How we do this depends on what we know about efficiency

-   manufacturer reports mean and standard deviation\*
-   manufacturer provides a range

Mean 0.6 standard deviation of 0.1

# R code

```{r sen1, eval=T, echo=TRUE}
library(tidyverse)

# first come up with varying values for efficiency 
# if we don't know efficiency exactly , lets try 20 samples


eff <- rnorm(mean = 0.6, sd = 0.1, n = 20)

# use map from purrr to run model for all values of eff
# notice how map adds the one parameter that is missing from the input list

site2 <- eff %>% map(~ solarpv(area = 0.1, 
  solar = sierraczosolar, clr = "green", 
  eunit = "W", g = FALSE, etype = "direct", eff = .x))

head(site2)
```

## Data Structures {.scrollable}

-   challenge in sensitivity analysis is often what data structure to use to store the results

-   organize parameter variation and result variation

-   R often returns lists - but not so easy for organization

-   ask yourself what you want to do with the data, then put in a structure that will make this easy

-   e.g two different data frames

    -   plot variation in mean annual electricity by *eff*
    -   plot variation in each year due to variation in *eff*
    -   a data frame is often the best structure for graphing

```{r sen1b, eval=T}

head(str(site2))
# this is pretty messy - but we can extract a useful data structure,lets say we want
# just the annual data (not the mean annual time series), and then reformat as a data frame with nice column names
tmp <- map_dfr(site2, `[`, c("annual"))

site2df <- data.frame(year = tmp$annual$year, elect = tmp$annual$elect)
head(site2df)
```

## Looking at results from informal sensitivity analysis {.scrollable}

-   [Box plots or Violin Plots of Model Output (where box shows effect of parameter uncertainty)]{style="color: green;"}

WHY: To see how big the range of output might be relative to "uncertain" parameter range

-   [Plot Response against parameter value]{style="color: green;"}

WHY: To see how the parameter influences the results

-   [Average across parameter uncertainty]{style="color: green;"}

WHY: If you want the one number that is the "best guess" given uncertainty

## Variation in annual electricity due to parameter uncertainty {.scrollable}

-   boxplot
-   just need all the annual electricity by year

```{r sen2, eval=T, echo=TRUE}


# now we could plot
ggplot(site2df, aes(year, elect, group = year)) +
  geom_boxplot() +
  labs(y = "Electricity generated in W")
```

## Add an average line

Why?

```{r sen2b, eval=T, echo=TRUE}
# we also might want an average across parameter uncertainty
site2_average <- site2df %>%
  group_by(year) %>%
  dplyr::summarize(elect = mean(elect))

# now add this to the plot - note that we remove the grouping by using group=1
ggplot(site2df, aes(year, elect, group = year)) +
  geom_boxplot() +
  labs(y = "Electricity in W") +
  geom_line(data = site2_average, aes(year, elect, group = 1), col = "orange")
```

## How does efficiency impact mean annual electricity estimate {.scrollable}

-   Data structure with *eff* and mean annual electricity
-   X-Y plots

Organize the data

```{r sene, eval=T, echo=TRUE}
# we could also plot how the mean annual electricity varies with efficiency (eff from above)
site2[[1]]

tmp <- map_df(site2, `[`, c("mean"))

# how variable is electricity generation (mean over all time) with uncertainty in solar efficiency

site2_mean <- data.frame(eff = eff, elect = tmp)
```

## Plot {.scrollable}

-   how variable is the model output given parameter variation
-   how does the variation in parameter impact model output

```{r sene2, eval=T, echo=TRUE}
ggplot(site2_mean, aes(y = mean)) +
  geom_boxplot() +
  labs(x = "Electricity in W")

# or to see what the sensitivity looks like
ggplot(site2_mean, aes(eff, mean)) +
  geom_point() +
  labs(y = "Electricity in W", x = "Solar Efficiency")

# my best guess
mean(site2_mean$mean)
```

# Sharing Example R, Data and Rmarkdowns

<https://github.com/naomitague/ESM232_EDS230_Examples.git>

You can clone this repository and then pull before class to get example code and data

Remember that git does not like having nested repositories - so keep working respoistories in separate directories

## Combined sensivitivity analysis

-   *eff*

-   *ethresh*

Sample from both of them - each time we run the model we vary both of the parameters at the same time

Then create plots to show the impact of parameter uncertainty

## Combined parameter sensitivity

Two possible approaches

-   *for*
-   *pmap* from purrr (when you want to vary more than one input to the model)

## using *pmap* {.scrollable}

```{r secondsensitivity, echo=TRUE}
# generate samples for both parameters
nsamples <- 300
deviation <- 0.15
base_thresh <- 10000
ethresh <- runif(
  min = base_thresh - deviation * base_thresh,
  max = base_thresh + deviation * base_thresh, n = nsamples
)

eff <- rnorm(mean = 0.6, sd = 0.1, n = nsamples)

# put samples together
parms <- cbind.data.frame(eff, ethresh)

# use pmap
# takes function name and then names of all parameters that don't change
results <- parms %>% pmap(solarpv,
  area = 0.1,
  solar = sierraczosolar, clr = "green",
  eunit = "W", g = FALSE, etype = "direct"
)

results[[1]]
length(results)

# now we can extract results from the list as above
mean_elect <- map_df(results, `[`, c("mean"))
# and we can add the parameter values for each run
mean_elect <- cbind.data.frame(mean_elect, parms)

# plot - pick one of the 2 parameter as a color
# try switching which parameter used for color

p1 <- ggplot(mean_elect, aes(ethresh, mean, col = eff)) +
  geom_point(cex = 2) +
  labs(y = "Mean Annual Electricity W", x = "Threshold Radiation (kJ/m2)  \n above which energy production is more efficient")
p1

p2 <- ggplot(mean_elect, aes(eff, mean, col = ethresh)) +
  geom_point(cex = 2) +
  labs(y = "Mean Annual Electricity W", x = "Efficiency")
p2


# extract annual
# plot total uncertainty due to both parameters
tmp <- map_df(results, `[`, c("annual"))
solar_annual_elect <- as.data.frame(tmp$annual$year)
colnames(solar_annual_elect) <- "year"
solar_annual_elect$elect <- tmp$annual$elect

ggplot(solar_annual_elect, aes(year, elect, group = year)) +
  geom_boxplot() +
  labs(y = "Electricity generated in W")

# save this model output for next lecture
save(solar_annual_elect, file = here("Data/annual_elect_solar.rda"))
```

# Sensitivity to two different parameters

-   note how one parameter **eff** overshadows the response to *"ethresh*

-   note the linear response to *eff*

## plot

```{r}
ggarrange(p1, p2)
```

## Additional notes {.scrollable}

Using a *For* Loop for sensitivity analysis

```{r}
# using a for loop
# start by creating a data structures to hold results, separate
# for scenario mean and annual values
mean_elect_for <- rep(NA, times = nsamples)
# for annual we need rows as years, columns for samples
years <- unique(sierraczosolar$year)
annual_elect_for <- as.data.frame(matrix(ncol = nsamples, nrow = length(years)))
annual_elect_for$year <- years


for (i in 1:nsamples) {
  res <- solarpv(
    area = 0.1, solar = sierraczosolar,
    clr = "green", eunit = "W", g = FALSE, etype = "direct",
    ethresh = parms$ethresh[i],
    eff = parms$eff[i]
  )

  annual_elect_for[, i] <- res$annual$elect
  mean_elect_for[i] <- res$mean
}

# plot
me <- cbind.data.frame(mean = mean_elect_for, parms)
ggplot(me, aes(eff, mean, col = ethresh)) +
  geom_point(cex = 2) +
  labs(y = "Mean Annual Electricity W", x = "Efficiency")

tmp <- annual_elect_for %>% pivot_longer(cols = -c(year))

# get rid of that pesky first year
tmp <- subset(tmp, tmp$year > 1944)

ggplot(tmp, aes(as.factor(year), value)) +
  geom_boxplot() +
  labs(y = "Mean Annual Electricity W", x = "Year")
```

# Before next Tuesday I'll add a part 2 to this lecture

In preparation, go through informal_sensitivity.qmd and informal_sensitivity2.qmd make sure you understand the code
