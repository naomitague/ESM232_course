---
title: "Calibration"
format: revealjs
execute: 
  echo: TRUE
theme: solarized
resources: ["img/"]
css: ["slides.css"]
editor: visual
---

# Calibration

choosing parameters based on performance

will be sensitivity

-   parameter sampling

-   performance metric

-   performance context (time period, space.., accuracy of measurements)

## Approach Summary

-   Generate parameter sets (e.g., Sobol)
-   Compute metrics for each
-   Reject poor performers
-   Retain ALL acceptable sets
-   Use ensemble to represent uncertainty

## Example: Part 1

-   Why metrics matter
-   Equifinality
-   R-code (re-usable for off the shelf models)

## Hydrologic model example

RHESSYs application to Sagehen Creek in California Sierra ![Sagehen](img/Sagehenloc.png)

## Hydrologic model example

![Sagehen](img/Sagehenpic.png)

## RHESSys

![RHESSys](img/RHESSys.png)

## RHESSys {.scrollable}

-   run for 101 parameter sets

Each parameter set

-   Water year 1966 to 1990
-   Streamflow each day
-   Table organized each run in a column

And we have observed data

-   Which parameter sets are acceptable?
-   What if we just pick the best one?

## Load the data {.scrollable}

```{r echo=TRUE, eval=TRUE}
library(tidyverse)
library(here)

msage = readRDS(here("Data/msage.RDS"))
#View(msage)

# first rearrange so we can plot all results
msagel = msage %>% gather(key="run",value="str", -date, -month, -day, -year, -wy,-obs)

# now plot
p1=ggplot(subset(msagel, wy == 1970), aes(as.Date(date), str, col=run))+geom_line()+theme(legend.position = "none")
p1

# lets add observed streamflow
p1+geom_line(data=subset(msage, wy == 1970), aes(as.Date(date), obs), linewidth=2, col="black", linetype=2)+labs(y="Streamflow", x="Date")


# try another year
```

## Calibration metrics for each parameter set {.scrollable}

-   NSE
-   Low flow metrics

```{r, echo=TRUE, eval=TRUE}

source(here("R/nse.R"))
nse

# compute nse for each parameter set
res = msage %>% select(-date, -month, -day, -year, -wy, -obs ) %>% apply(2,nse, o=msage$obs)
head(res)
summary(res)

# basic calibration would be picking a single parameters set
best_par = which.max(res)
# lets plot the best parameter set

ggplot(msage, aes(as.Date(date), msage[,best_par]))+geom_line(col="red")+
  geom_line(data=msage, aes(as.Date(date), obs), col="black", linetype=2)+labs(y="Streamflow", x="Date")

# what would be acceptable?

```

## Try again with low flow metrics {.scrollable}

a function that generates

-   error in estimating minimum annual flow
-   correlation in minimum annual flow
-   error in estimates of a given month
    -   user can pick low flow month
-   correlation for that month (each year)

```{r, echo=TRUE, eval=TRUE}
source(here("R/compute_lowflowmetrics.R"))

# another example using our low flow statistics
# use apply to compute for all the data
res = msage %>% select(-date, -month, -day, -year, -wy, -obs ) %>% apply(2,FUN=compute_lowflowmetrics, o=msage$obs, month=msage$month, day=msage$day, year=msage$year, wy=msage$wy)

# extract information from the list
results = as.data.frame(matrix(unlist(res), byrow=T, ncol=4))
colnames(results)=c("annual_min_err","annual_min_cor", "low_month_err",
              "low_month_cor")

# interesting to look at range of metrics - could use this to decide on
# acceptable values
summary(results)

# graph range of performance measures
resultsl = results %>% gather(key="metric",value="value")
ggplot(resultsl, aes(metric, value))+geom_boxplot()+facet_wrap(~metric, scales="free")

# how might you pick best parameter sets

```

# Performance metrics matter

-   similar to how we summarize results from space-time models

-   what do you care about?

-   test that your model captures behavior that you are interested in

# Once your have performance

Standard - pick one set

Issues
* highly sensitivity to observation error
* highly sensitivity to performance metric
* highly sensitivity to observation context (e.g. time period)
* equifinality (are performance difference really meaningful)

```{r, echo=TRUE, eval=TRUE}

# pick parameter set with greater low flow month correlation

best_par2 = which.max(results$low_month_cor)

# is it the same as what we got with nse


```

## Alternative Create a combined performance measure {.scrollable}

-   combine multiple performance measures into a single one

-  we need to transform error based metrics into 0-1 scale, and make sure better performance is a higher value of the metric

- fix
    - errors : $L_{err} = 1 - \frac{|err|}{max(|err|)}$
 
- create a general function that will work with any number of metrics   
    
```{r, echo=TRUE, eval=TRUE}

comb_metrics = function(metrics, weights) {
  # how many metrics
  n_metrics = ncol(metrics)
  new_metrics = metrics
  # make sure weights sum to 1
  if (sum(weights) != 1) {
 #   return("weights must sum to 1")
  }
  #  if err based transform it to 0-1 where positive  is good performance
  for (i in 1:n_metrics) {
    if (grepl("err", colnames(metrics)[i])) {
      # error based metric, transform it
      new_metrics[,i] = 1 - (abs(metrics[,i]) / max(abs(metrics[,i])))
    }
    # else assume correlation based metric already 0-1
  }
  
  # matrix multiplication to get weighted sum
  combined_metric = as.vector(as.matrix(new_metrics) %*% as.matrix(weights))
 
  # alternatively slower for loop
#  combined_metric = rep(0, nrow(metrics))
#  for (i in nrow(new_metrics)) {
#    for (j in 1:n_metrics) {
#      combined_metric[i] = combined_metric[i] + weights[j] *   new_metrics[i,j]
#    }
# }
  
  # return
  return(combined_metric)
}

# apply to our results
weights = c(0.25, 0.25, 0.25, 0.25)
comb_results = comb_metrics(results[,1:4], weights)
summary(comb_results)

# for graphing might be useful to add to our results data frame
results$combined = comb_results

# you can get a sense of how different metrics contribute to combined metric
ggplot(results, aes(combined, annual_min_cor))+geom_point()+labs(y="Annual Min Correlation", x="Combined Metric")
```

## Alterantive Parameter Selection {.scrollable}

Lets keep all parameters that give reasonable values

```{r, echo=TRUE, eval=TRUE}

# first we need to be able to identify parameter sets in results

ID = msage %>% select(-date, -month, -day, -year, -wy, -obs ) %>%  colnames()
results$id = ID

# now we can pick only good parameters
accept_par = subset(results, annual_min_cor > 0.7 & low_month_cor > 0.7 & abs(annual_min_err < 0.2) & abs(low_month_err) < 5)
nrow(accept_par)

#  plot these to compare with all parameters
msagel$accept = ifelse(msagel$run %in% accept_par$id, TRUE, FALSE)
ggplot(subset(msagel, accept), aes(as.Date(date), str))+geom_line()

# or with observed but focus on August flow
msagel_mth = msagel %>% select(-date,-day) %>%  group_by(month, wy, run, accept) %>% summarise(str=mean(str, na.rm=T), obs=mean(obs, na.rm=T))

# just august flow
ggplot(subset(msagel_mth,  month==8 & accept),
       aes(wy, str, group=wy))+geom_boxplot(position="dodge")+
  geom_point(aes(wy, obs), col="red")+labs(y="Streamflow", x="Date")

mean_august_obs = mean(subset(msagel_mth, month==8)$obs) 
ggplot(subset(msagel_mth, month==8), aes(accept, str))+geom_boxplot()+
  geom_hline(yintercept=mean_august_obs, col="red")+labs(y="Streamflow", x="Date")
```

# Alternatively we could just use our combined metric
```{r, echo=TRUE, eval=TRUE}

# pick acceptable parameters based on combined metric
accept_par2 = subset(results, combined > 0.7)
nrow(accept_par2)
#  plot these to compare with all parameters
msagel$accept2 = ifelse(msagel$run %in% accept_par2$id, TRUE, FALSE)
ggplot(subset(msagel, accept2), aes(as.Date(date), str))+geom_line()
# or with observed but focus on August flow
msagel_mth2 = msagel %>% select(-date,-day) %
%  group_by(month, wy, run, accept2) %>% summarise(str=mean(str, na.rm=T), obs=mean(obs, na.rm=T))
# just august flow
ggplot(subset(msagel_mth2,  month==8 & accept2),
       aes(wy, str, group=wy))+geom_boxplot(position="dodge")
  geom_point(aes(wy, obs), col="red")+labs(y="Streamflow", x="Date")
mean_august_obs = mean(subset(msagel_mth2, month==8)$obs)
ggplot(subset(msagel_mth2, month==8), aes(accept2, str))+geom_boxplot()+
  geom_hline(yintercept=mean_august_obs, col="red")+labs(y="Streamflow", x="Date")
```

[Assignment](assignments/Assignment8_Calibration.qmd)
