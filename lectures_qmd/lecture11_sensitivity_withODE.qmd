---
title: "Sensitivity with ODEs"
format: revealjs
theme: solarized
resources: ["img/"]
css: ["slides.css"]
editor: visual
---

```{r setup, include=FALSE}
library(tidyverse)
library(deSolve)
library(here)
library(sensitivity)
```

## Sensitivity Analysis of a Differential Equation {.scrollable}

We can apply sensitivity analysis to a differential equation

A key issue where is sensitivity of what?

Dynamic models often give you many many outputs

-   time series (streamflow every day for a year, population for 30 years)
-   or output over space (spatially averaged concentration after 10 days?)

So if we are asking 'sensitivity of what' we need to summarize results in some way (reduce their dimensionality )

## Some options for reducing output dimensionality (summarizing output) {.scrollable}

Depends on what is important for your model application

-   max
-   mean
-   min
-   total
-   variation
-   time it takes for something to happen

So a key step in sensitivity analysis with a dynamics model is summarizing results into a few key measures

Its useful to turn that summarizing workflow into a function

## Workflow for Sensitivity Analysis {.scrollable}

1)  implement (or identify pre-existing) dynamic model

2)  obtain samples of parameter sets (from sobel or LHS)

3)  build a function that will extract the information (metrics) you want from your dynamic model (output of the ode)

4)  create a data structure to store the metrics for each parameter set - in my example I call it metrics (but could be anything)

5)  decide on initial conditions and time period over which you will run the model

6)  run ODE for each parameter sets to fill in this metrics data structure

    -   its usually helpful to create a wrapper function
        -   runs ODE
        -   extracts metrics
    -   run wrapper function for each parameter sets

7)  send the metrics back to the sensitivity analysis object (from sobel or LHS)

8)  plot and analyze results

## Example ODE sensitivity with a population model {.scrollable}

This one includes a carrying capacity

Step 1 and 2 with population model

Always a good practice to "try" you model on one parameter set *before* trying to run for all parameters

```{r sen}
source(here("R/dpopgrowth.R"))

dpopgrowth

# lets start with sobel
library(sensitivity)

# come up with first set of sample parameters
# we will assume that we know the initial population,

Pinitial <- 10

# want to learn about sensitivity to growth rate (r) and carrying capacity
# set the number of parameters
np <- 2000
# Assume parameters are normally distributed
# sample K with mean of 200, standard devidation of  50
# sample r with mean of 0.02 and standard deviation of 0.005
K <- rnorm(mean = 200, sd = 50, n = np)
r <- rnorm(mean = 0.02, sd = 0.005, n = np)
X1 <- cbind.data.frame(r = r, K = K)

# repeat to get our second set of samples
K <- rnorm(mean = 200, sd = 50, n = np)
r <- rnorm(mean = 0.02, sd = 0.005, n = np)
X2 <- cbind.data.frame(r = r, K = K)

# fix any negative values and they are not meaningful
X1 <- X1 %>% map_df(pmax, 0.0)
X2 <- X2 %>% map_df(pmax, 0.0)

# create our sobel object and get sets ofparameters for running the model

sens_P <- sobolSalt(model = NULL, X1, X2, nboot = 300)

# our parameter sets are
head(sens_P$X)

# lets add names
colnames(sens_P$X) <- c("r", "K")

head(sens_P$X)
```

## Running the ODE and summarizing output {.scrollable}

Step 3-6 in workflow

Run our differential equation for all parameters and keep

-   the output - volume of output quickly becomes a problem

Just save metrics

A couple of options

-   how about maximum population if we run the model for 200 years,
-   how many years to get to the carrying capacity
-   how many year to get to some pre-determined threshold

## Streamlining workflow with functions

Create two additional functions that will help us

-   a function that computes the metrics we want

-   a function that runs our ode solver and computes the metrics (I call it a **wrapper** function as it is really just a workflow/wrapper to call ode solver and then compute metrics)

-   wrapper takes as input

    -   parameters
    -   initial conditions
    -   simulation time
    -   ode (function name)
    -   how to compute metrics (function name)

-   always test to make sure it works (good coding practice)

```{r sen2}
# turn computing our metrics into a function


compute_pop_metrics <- function(result, thresh) {
  # first add maximum population
  maxpop <- max(result$P)
  
  # find when populatin is greater than the threshold
  idx <- which(result$P > thresh)[1]
  # account for sitation with threshold is never reached
  idx <- ifelse(is.na(idx), length(result$P), idx)
  threshyear <- result$time[idx]
  # return results
  return(list(maxpop = maxpop, threshyear = threshyear))
}

# Test that it works
# try it on our first parameter set, and look at when it gets to 100
# initial population
Pinitial=10
# run for 500 days
simtimes = seq(from=1, to=500, by=5)
# use the first parameter set (or you could just pick a test value), not the list because ode wants parameters as a list, so name each
parmtest = list(r=sens_P$X[1,"r"],K=sens_P$X[1,"K"])

# run ode
result = ode(y = Pinitial, times = simtimes, func = dpopgrowth, parms = parmtest)
# turn ode results into a labelled data frame 
result = data.frame(time=result[,1], P=result[,2])
# run metrics on results
compute_pop_metrics(result, 100)

# great but we need to apply the ode and this function for all of our parameters

# define a wrapper function to do everything we need - run solver and compute metrics - and send back results for each parameter

# lets make the threshold 90% of carrying capacity
p_wrapper <- function(r, K, Pinitial, simtimes, odefunc, metricfunc, metricpars) {
  
  # create parameter list
  parms <- list(r = r, K = K)
  
  # run ode
  result <- ode(y = Pinitial, times = simtimes, func = odefunc, parms = parms, method="euler")
  
  # results as a data frame
  result = data.frame(time=result[,1], P=result[,2])
  # get metrics
  
  # compute metrics
  metrics <- metricfunc(as.data.frame(result), metricpars$thresh)
  return(metrics)
}


# test with specific r and K values (r=0.01, K=150)
# set out threshold 
metricpars = list(thresh=100)
p_wrapper(
  r = 0.01, K = 150, Pinitial = 3, simtimes = seq(from = 1, to = 10),
  odefunc = dpopgrowth, metricfunc = compute_pop_metrics, metricpars = metricpars
)

# try with first row of our Sobol parameters
p_wrapper(r=sens_P$X[1,"r"], K=sens_P$X[1,"K"],
          Pinitial=10, simtimes=simtimes, odefunc=dpopgrowth,
          metricfunc=compute_pop_metrics, metricpars)
```

## Next step {.scrollable}

Run the wrapper for all parameters and look at results

```{r userwarpper, error=TRUE}
# now use pmap as we did before

allresults <- as.data.frame(sens_P$X) %>% pmap(p_wrapper, Pinitial = Pinitial, simtimes = simtimes, odefunc = dpopgrowth, metricfunc = compute_pop_metrics, metricpars=list(thresh=100))

# extract out results from pmap into a data frame
allres <- allresults %>% map_dfr(`[`, c("maxpop", "threshyear"))

# do a quick summary to get a sense of the range
summary(allres)
# create boxplots of our two metrics for all parameters - use facet wrap since population and year are different y-axis
tmp <- allres %>% pivot_longer(cols = everything(), names_to = "metric", values_to = "value")
ggplot(tmp, aes(metric, value)) +
  geom_boxplot()+facet_wrap(~metric, scales="free")
```

## Compute the sobol indicies for each metric {.scrollable}

-   save the *tell* to different objects so you can keep re-using the original sobol object

-   look at total effect and first order sensitivity

-   Step 7 in workflow

```{r sen3}
# sobol can only handle one output at a time  - so we will need to do them separately


# lets start with threshyear
# "tell" the sensitivity analysis object - re-name so we keep separate
sens_P_threshyear <- sensitivity::tell(sens_P, allres$threshyear)
# first-order indices (main effect without co-variance)
rownames(sens_P_threshyear$S) <- c("r", "K")
sens_P_threshyear$S

# total sensitivity index -note that this partitions the output variance - so values sum to 1
rownames(sens_P_threshyear$T) <- c("r", "K")
sens_P_threshyear$T

# graph metric against most parameter that the output is most sensitive to, using #2 for color
# create a data frame
allresp = as.data.frame(cbind(sens_P$X, allres))
ggplot(allresp, aes(K, threshyear, col=r ))+geom_point()+
  labs(y="Year that threshold is reached", x="K")
```

## Repeat for Maximum Population Reached {.scrollable}

remember to create a different sens_P object

```{r senpop}

# create another one for max population
sens_P_maxpop <- sensitivity::tell(sens_P, allres$maxpop)

# first-order indices (main effect without co-variance)
rownames(sens_P_maxpop$S) <- c("r", "K")
sens_P_maxpop$S

# total sensitivity index -note that this partitions the output variance
rownames(sens_P_maxpop$T) <- c("r", "K")
sens_P_maxpop$T

# graph metric against most parameter that the output is most sensitive to, using #2 for color
# create a data frame
allresp = as.data.frame(cbind(sens_P$X, allres))
ggplot(allresp, aes(K, maxpop, col=r ))+geom_point()+
  labs(y="Year that threshold is reached", x="K")
```

## Negative sobol first order indices {.scrollable}

if confidence interval includes zero - not a problem

if it doesn't there are numerical issues - try running more samples

## Error messages from Sobol {.scrollable}

*All values of t are equal to 0.999999999999856* \n Cannot calculate confidence intervals

relationship looks like its completely prescribed - which is true in the case of carrying capacity

## Error messages from ODE {.scrollable}

*In lsoda(y, times, func, parms, ...) : an excessive amount of work (\> maxsteps ) was done, but integration was not successful - increase maxsteps*

Suggest that the solver (numerical integration) had issues

-   increasing maxsteps can help

    ```         
    *result = ode(y=Pinitial, times=simtimes, func=func, parms=parms, maxsteps=100000) *
    ```

-   trying different methods

    ```         
    *result = ode(y=Pinitial, times=simtimes, func=func, parms=parms, method="daspk")*
    ```

-   "stiff" problems are harder for numerical integration to solve - (small changes have big impacts); a threshold carrying capacity does that \## Ways to use dynamic models {.scrollable}

Goal: To provide insight into environmental systems, and how they respond to intervention/disturbance/change

-   predict how something we care above will change over space and/or time (*system evolution*)

-   sensitivity analysis of output

    -   output response to variation in inputs/parameters
    -   quantifying how summary measures respond to variation in inputs/parameters


## [Assignment]{style="color:orange"} {.scrollable}

Assignment6 - Using Sobol with an ODE
