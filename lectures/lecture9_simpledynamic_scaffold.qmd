---
title: "Lecture 9: Simple Dynamic Models"
format: revealjs
theme: solarized
resources: ["img/"]
css: ["slides.css"]
editor: visual
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(purrr)
library(deSolve)
library(here)
```

## Partner Exercise

Discuss examples of dynamic systems \* spatial interaction \* temporal interaction \* both

Think of a model where you might have a multi-dimensional system state

-   what variables would define the state-space

-   what would control the evolution of the state-space

-   what would be the initial conditions

Add your answer to the Quiz

## Simple Example {.scrollable}

Exponential Growth - Simple Dynamic System

-   rate of growth(change) *r*
-   *P* population(density)

Differential equation - $dP$ / $dt$ = $rP$

## Exponential Growth - Simple Dynamic System {.scrollable}

-   differential equation

$dP$ / $dt$ = $rP$

-   an analytic solution exists so we can write Population as a function of time by integrating both sides

-   $P = PO * exp(rt)$

This is a regular input-output function - that gives population after some time t

## Simple Implementation {.scrollable}

```{r exppop1, echo=TRUE}

source(here("R/exppop.R"))
# look at implementation of analytical solution 
exppop

# lets look at how this models population over time
# create a variable (years) to track time


# use map_dbl to run our model for all years
# assume some initial conditions of 20 individuals and growth rate 0.01


# keep track of what times we ran by adding years to data.frame


# plot

```

## Integration, or Solving Differential Equations {.scrollable}

We want the value of the dependent variation (population) over a range of values for independent variable (time)

-   We know how dependent variable is changing (that's the differential equation)

$dP / dt = rP$

-   For each P we can approximate the next P after a small time period

-   $P_{t+1} = P + dP / dt *  Timestep$

-   But as P changes $dP /dt$ changes so we have to keep time step small (really small if possible)

## Implementing Dynamic Models in R {.scrollable}

Dynamic models always involves derivatives (equations that express how things change from time step to time step or place to place )

Implement population growth as a derivative - a model of population change

```{r derivaties, echo=TRUE, eval=TRUE}
# note that we include time here but we don't use it; we will need this later
source(here("R/dexppop.R"))

# look at how we implement derivative
dexppop

# see how it works - run with population of 20, growth rate 0.01



# what is this?

# notices that it doesn't matter what you use for t 
# this is just how R works with derivatives


# lets look at this for a range of initial populations (1 to 100)
# create population sequence


# compute rate of change of population (growth) for each population value

```

## plotting the derivative (rate of change) {.scrollable}

```{r, plotderivatives, echo=TRUE}

# plot rate of change by population

```

-   why is this a straight line?
-   how many new individuals are born at each population level

## Integration {.scrollable}

What if we wanted to look at population in 20 years given an initial condition

Two options

1)  explicit solution to differential equation is known; e.g. you can integrate both sides of the equation!

-   we did this above - $P = PO * exp(rt)$ coded in *exppop.R*
-   you can get the answer exactly and quickly this way

2)  not integrable

-   must be solved by iteration; this is what we do when we can't integrate both sides

# Example {.scrollable}

Continue looking at our rabbit population but we can't solve it..

-   iterate through time

-   calculate rate of change at initial conditions (e.g value of differential equation for initial conditions)

-   add that value to initial conditions, to create state at time t + 1

-   re-calculate rate of change (e.g value of differential equation for state at time t+1)

-   keep doing this

Key questions is how much of a "jump" in t do we do

If you do this you are "kind of" turning the differential equation into a difference equation

## Solving by thinking of problem as a difference equations {.scrollable}

Population models can be discrete (rather than continuous)

So we could implement them as difference equations and iterate

```{r iterate1}
source(here("R/discrete_logistic_pop.R"))
# look at function
# notice how a for loop is used to iterate

discrete_logistic_pop

# how many rabbits after 50 years given a growth of 0.05
# starting with 1 rabbit - but a carrying capcity of200


# save results


# lets also keep the parameters for use later

```

## Compare discrete and analytic results {.scrollable}

Save the results from both to compare

```{r closed}

# reload our analytical model
source(here("R/exppop.R"))

# run exppopK for P0, r, K, T (same conditions as discrete)

# compare values (endpoints)

# why are they different
# look at trajectories for each point in time from 1 to 100

# create a dataframe to store results with time as first column

# add a column using analytical growth model

# add a column using discrete growth model

```

## Graph

```{r, graph2, eval=TRUE, echo=TRUE}

# gather both model results using a key called "Ptype", value "P"

# plot with model type as color


# try running them for longer time periods to see what happens
# change the value of r, K , P0 - see how it effects the results

```

## Summary of what we've done

-   exppop - analytical solutions to population differential equation

-   discrete_logistic_pop - integrating by stepping through time

-   dexppop - the derivative (would need to be integrated to get populations over time), no carrying. capacity

## Solving using numeric integration {.scrollable}

Using a solver....when you can't do the integration by hand :)

Solvers integrate by iteration but doing so in a way that more closely *approximates* analytic integration

Use mathematical tricks to deal with the fact that the rate of change keeps changing :)

There are different types of *solvers*, some work better than others depending on the form of the derivative

## Numerical integration with ODE {.scrollable}

Implement the differential equation as a function that

-   returns the derivative (as a list)

-   inputs time, the variable(s) and a parameter list

(it needs time even though you donâ€™t use it)

My convention: name derivative functions starting with *d* to remind myself that they are computing a derivative

## ODE

Only works for Ordinary Differential Equations - single independent variable (in our case time)

Partial differential equations - more than 1 independent variable (e.g x and y if changing in space)

R has a solver called *ODE* for solving ordinary differential equations from package **desolve**

## *ODE* requires {.scrollable}

-   initial conditions
-   values of independent where we want values of dependent variable (e.g times where we want population)
-   the derivative as a function
-   a list that contains all parameter values (or if you have only one parameter then you can use a single value)

## ODE example {.scrollable}

```{r usingode}
source(here("R/dexppop.R"))

dexppop
library(deSolve)

# create initial conditions 20 rabbits

# create a vector of years that you want results for - we can skip years (by 2)


# run the ode solver

# added column names


# notice (by using attributes) that there are additional pieces of information including the method used for integration

# this also means you need to extract just the data frame for plotting
# make results a data frame

# you can also run ode with function inputs in order but better to use names
Ptime <- ode(initialrabbits, years, dexppop, 0.01)
colnames(Ptime) <- c("year", "P")
ggplot(as.data.frame(Ptime), aes(year, P)) +
  geom_point() +
  labs(y = "Population", "years")



```

## Comparing approaches {.scrollable}

-   analytical
-   numerical integration by hand
-   using an ODE solver to do the numerical integration

```{r, all, echo=TRUE }
# set r

# create a dataframe to store results with time as first column


# add a column using analytical growth model


# add a column using discrete growth model


# add a column using ode


# gather both model results using a key called "Ptype", value "P"

# plot with model type as color


```

-   try running them for longer time periods to see what happens
-   change the value of r, P0 - see how it effects the results

## Add carrying capacity

try this - add a carrying capacity

$$
\frac{dP}{dt} =
\begin{cases}
0, & P \ge K \\
r, & P < K
\end{cases}
$$

alternative

$$
\frac{dP}{dt} = r \, \max\!\left(0, 1 - \frac{P}{K}\right)
$$

## Explicit Solution is available {.scrollable}

Even with carrying capacity there is an analytical solution, depending on how you think about carrying capacity

Will use a "hard" threshold (no decline in growth rate until carrying capacity is reached) - you can still use the same equation, and just add a limit

```{r explicit}
source(here("R/exppopK.R"))

exppopK

# gives population after any time given an initial population

# 20 rabbits initially, growth rate of 0.01 how many in 30 years
exppopK(T = 30, P0 = 20, r = 0.01, K = 40)

# if we want to see how population evolves over time - generate a time series by running our model for each point in time

# set a variable for initial conditions
initialrabbits <- 20
# create vector of all years we want population values for
years <- seq(from = 1, to = 100, by = 2)

# use map_dbl to run the model for all of these years
Ptime <- years %>% map_dbl(~ exppopK(P0 = initialrabbits, r = 0.01, K = 40, T = .x))

# keep track of what times we ran by adding years to our data frame 
Ptime <- data.frame(P = Ptime, years = years)

# plot population for different years
p=ggplot(Ptime, aes(years, P)) +
  geom_point() +
  labs(x = "years", y = "Rabbit Population")
p

```

## *Homework* {.scrollable}

Try to modify *dexppop* so that it includes carrying capacity and compare with what we did for our analytic solution (use the ode solver to integrate)
